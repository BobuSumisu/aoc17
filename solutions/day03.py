#
#   Advent of Code 2017
#   ===================
#
#   Day 3: Spiral Memory
#   --------------------
#
#   Input
#       A square number spiral and a target number n.
#   Notes
#
#   Output A
#       The Manhattan distance from square n to origin.
#   Output B
#       The first "neighbour sum" above n.
#   Comments
#       The spiral walking functions is quite naive: we simply repeatedly walk an
#       "arm", turn left, walk an arm, turn left and increase arm length.
#
#       There are probably some fancy way of doing this. All diagonals
#       of the number spiral can be expressed as polynomials on the form: 4x^2 + bx + c.
#
#       The sequence generated by part two is actually described in OEIS[1] as
#       Â«Square spiral of sums of selected preceding terms, starting at 1.Â»
#
#       [1] https://oeis.org/A141481

def add(a, b):
    """Add two 2D vectors."""
    return (a[0] + b[0], a[1] + b[1])

def rotate90(a):
    """Rotate a 2D vector 90 degrees to the left."""
    return (-a[1], a[0])

def manhattan(a, b):
    """Calculate Manhattan distance between to 2D vectors."""
    return abs(b[0] - a[0]) + abs(b[1] - a[1])

def neighbours(a):
    """Get the 8 neighbouring cells of a 2D point."""
    return [
        (a[0] + 1, a[1] + 0),
        (a[0] + 1, a[1] + 1),
        (a[0] + 0, a[1] + 1),
        (a[0] - 1, a[1] + 1),
        (a[0] - 1, a[1] + 0),
        (a[0] - 1, a[1] - 1),
        (a[0] + 0, a[1] - 1),
        (a[0] + 1, a[1] - 1),
    ]

def spiral_walk():
    """Generator walking a square number spiral, yielding location and coordinates."""
    loc = 1
    coords = (0, 0)
    dir = (1, 0)
    arm_len = 1
    turn_counter = 1
    inc_counter = 1

    while True:
        yield loc, coords
        loc += 1
        coords = add(coords, dir)

        turn_counter -= 1
        if turn_counter == 0:
            dir = rotate90(dir)
            turn_counter = arm_len

        inc_counter -= 1
        if inc_counter == 0:
            arm_len += 1
            inc_counter = arm_len * 2

def day03a(data):
    for loc, coords in spiral_walk():
        if loc == data:
            return manhattan(coords, (0, 0))

def day03b(data):
    grid = dict()

    for loc, coords in spiral_walk():
        if loc == 1:
            grid[coords] = 1
            continue

        neighbour_sum = sum(grid.get(n, 0) for n in neighbours(coords))
        grid[coords] = neighbour_sum
        if neighbour_sum > data:
            return neighbour_sum
